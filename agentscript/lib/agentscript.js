// Generated by CoffeeScript 1.7.1
(function() {
  var ABM, root, u, _base,
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.ABM = ABM = {};

  root = this;

  (function() {
    var vendor, _i, _len, _ref;
    this.requestAnimFrame = this.requestAnimationFrame || null;
    this.cancelAnimFrame = this.cancelAnimationFrame || null;
    _ref = ['ms', 'moz', 'webkit', 'o'];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      vendor = _ref[_i];
      if (!(!this.requestAnimFrame)) {
        continue;
      }
      this.requestAnimFrame || (this.requestAnimFrame = this[vendor + 'RequestAnimationFrame']);
      this.cancelAnimFrame || (this.cancelAnimFrame = this[vendor + 'CancelAnimationFrame']);
      this.cancelAnimFrame || (this.cancelAnimFrame = this[vendor + 'CancelRequestAnimationFrame']);
    }
    this.requestAnimFrame || (this.requestAnimFrame = function(callback) {
      return this.setTimeout(callback, 1000 / 60);
    });
    return this.cancelAnimFrame || (this.cancelAnimFrame = function(id) {
      return this.clearTimeout(id);
    });
  })();

  (_base = Array.prototype).indexOf || (_base.indexOf = function(object) {
    var i, x, _i, _len;
    for (i = _i = 0, _len = this.length; _i < _len; i = ++_i) {
      x = this[i];
      if (x === object) {
        return i;
      }
    }
    return -1;
  });

  Array.prototype._sort = Array.prototype.sort;

  ABM.util = u = {
    error: function(string) {
      throw new Error(string);
    },
    MaxINT: Math.pow(2, 53),
    MinINT: -Math.pow(2, 53),
    MaxINT32: 0 | 0x7fffffff,
    MinINT32: 0 | 0x80000000,
    Colors: {
      black: [0, 0, 0],
      white: [255, 255, 255],
      gray: [128, 128, 128],
      red: [255, 0, 0],
      yellow: [255, 255, 0],
      green: [0, 128, 0],
      blue: [0, 0, 255],
      purple: [128, 0, 128],
      brown: [165, 42, 42]
    },
    isArray: Array.isArray || function(object) {
      return !!(object && obj.concat && object.unshift && !object.callee);
    },
    isFunction: function(object) {
      return !!(object && object.constructor && object.call && object.apply);
    },
    isString: function(object) {
      return !!(object === '' || (object && object.charCodeAt && object.substr));
    },
    isNumber: function(object) {
      return !!(typeof object === "number");
    },
    randomSeed: function(seed) {
      if (seed == null) {
        seed = 123456;
      }
      return Math.random = function() {
        var x;
        x = Math.sin(seed++) * 10000;
        return x - Math.floor(x);
      };
    },
    randomInt: function(minmax, max) {
      if (minmax == null) {
        minmax = 2;
      }
      if (max == null) {
        max = null;
      }
      return Math.floor(this.randomFloat(minmax, max));
    },
    randomFloat: function(minmax, max) {
      var min;
      if (minmax == null) {
        minmax = 1;
      }
      if (max == null) {
        max = null;
      }
      if (max === null) {
        max = minmax;
        min = 0;
      } else {
        min = minmax;
      }
      return min + Math.random() * (max - min);
    },
    randomNormal: function(mean, standardDeviation) {
      var normal, u1, u2;
      if (mean == null) {
        mean = 0.0;
      }
      if (standardDeviation == null) {
        standardDeviation = 1.0;
      }
      u1 = 1.0 - Math.random();
      u2 = Math.random();
      normal = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
      return normal * standardDeviation + mean;
    },
    randomCentered: function(r) {
      return this.randomFloat(-r / 2, r / 2);
    },
    onceEvery: function(number) {
      if (number == null) {
        number = 100;
      }
      return this.randomInt(number) === 1;
    },
    log10: function(number) {
      return Math.log(number) / Math.LN10;
    },
    log2: function(number) {
      return this.logN(number, 2);
    },
    logN: function(number, base) {
      return Math.log(number) / Math.log(base);
    },
    mod: function(number, moduloOf) {
      return ((number % moduloOf) + moduloOf) % moduloOf;
    },
    wrap: function(number, min, max) {
      return min + this.mod(number - min, max - min);
    },
    clamp: function(number, min, max) {
      return Math.max(Math.min(number, max), min);
    },
    sign: function(number) {
      if (number < 0) {
        return -1;
      } else {
        return 1;
      }
    },
    colorFromString: function(colorName) {
      var color;
      color = this.Colors[colorName];
      if (!this.isArray(color)) {
        this.error("unless you're using basic colors, specify an rgb array [nr, nr, nr]");
      }
      return color;
    },
    randomColor: function() {
      var color, i, _i;
      color = [];
      for (i = _i = 0; _i <= 2; i = ++_i) {
        color[i] = this.randomInt(256);
      }
      return color;
    },
    randomGray: function(min, max) {
      var color, i, random, _i;
      if (min == null) {
        min = 64;
      }
      if (max == null) {
        max = 192;
      }
      color = [];
      random = this.randomInt(min, max);
      for (i = _i = 0; _i <= 2; i = ++_i) {
        color[i] = random;
      }
      return color;
    },
    randomMapColor: function(set) {
      if (set == null) {
        set = [0, 63, 127, 191, 255];
      }
      return [this.sample(set), this.sample(set), this.sample(set)];
    },
    randomBrightColor: function() {
      return this.randomMapColor([0, 127, 255]);
    },
    fractionOfColor: function(maxColor, fraction, color) {
      var i, value, _i, _len;
      if (color == null) {
        color = [];
      }
      color.string = null;
      for (i = _i = 0, _len = maxColor.length; _i < _len; i = ++_i) {
        value = maxColor[i];
        color[i] = this.clamp(Math.round(value * fraction), 0, 255);
      }
      return color;
    },
    brightenColor: function(color, fraction) {
      var newColor, value, _i, _len;
      newColor = [];
      for (_i = 0, _len = color.length; _i < _len; _i++) {
        value = color[_i];
        newColor.push(this.clamp(Math.round(value + fraction * 255), 0, 255));
      }
      return newColor;
    },
    colorString: function(color) {
      if (color.string == null) {
        if (color.length === 4 && color[3] > 1) {
          this.error("alpha > 1");
        }
        if (color.length === 3) {
          color.string = "rgb(" + color + ")";
        } else {
          color.string = "rgba(" + color + ")";
        }
      }
      return color.string;
    },
    colorsEqual: function(color1, color2) {
      return color1.toString() === color2.toString();
    },
    isLittleEndian: function() {
      var d32;
      d32 = new Uint32Array([0x01020304]);
      return (new Uint8ClampedArray(d32.buffer))[0] === 4;
    },
    degreesToRadians: function(degrees) {
      return degrees * Math.PI / 180;
    },
    radiansToDegrees: function(radians) {
      return radians * 180 / Math.PI;
    },
    substractRadians: function(radians1, radians2) {
      var PI, angle;
      angle = radians1 - radians2;
      PI = Math.PI;
      if (angle <= -PI) {
        angle += 2 * PI;
      }
      if (angle > PI) {
        angle -= 2 * PI;
      }
      return angle;
    },
    ownKeys: function(object) {
      var key, value, _results;
      _results = [];
      for (key in object) {
        if (!__hasProp.call(object, key)) continue;
        value = object[key];
        _results.push(key);
      }
      return _results;
    },
    ownVariableKeys: function(object) {
      var key, value, _results;
      _results = [];
      for (key in object) {
        if (!__hasProp.call(object, key)) continue;
        value = object[key];
        if (!this.isFunction(value)) {
          _results.push(key);
        }
      }
      return _results;
    },
    ownValues: function(object) {
      var key, value, _results;
      _results = [];
      for (key in object) {
        if (!__hasProp.call(object, key)) continue;
        value = object[key];
        _results.push(value);
      }
      return _results;
    },
    toFixed: function(array, precision) {
      var newArray, number, _i, _len;
      if (precision == null) {
        precision = 2;
      }
      newArray = [];
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        number = array[_i];
        newArray.push(number.toFixed(precision));
      }
      return newArray;
    },
    any: function(array) {
      return !u.empty(array);
    },
    empty: function(array) {
      return array.length === 0;
    },
    clone: function(array, begin, end) {
      var method;
      if (begin == null) {
        begin = null;
      }
      if (end == null) {
        end = null;
      }
      if (array.slice != null) {
        method = "slice";
      } else {
        method = "subarray";
      }
      if (begin != null) {
        return array[method](begin, end);
      } else {
        return array[method](0);
      }
    },
    last: function(array) {
      if (this.empty(array)) {
        this.error("last: empty array");
      }
      return array[array.length - 1];
    },
    sample: function(array, numberOrCondition, condition) {
      var checked, newArray, number, object;
      if (numberOrCondition == null) {
        numberOrCondition = null;
      }
      if (condition == null) {
        condition = null;
      }
      if (this.isFunction(numberOrCondition)) {
        condition = numberOrCondition;
      } else if (numberOrCondition != null) {
        number = Math.floor(numberOrCondition);
      }
      if (number != null) {
        newArray = [];
        object = true;
        while (newArray.length < number && (object != null)) {
          object = this.sample(array, condition);
          if (object && __indexOf.call(newArray, object) < 0) {
            newArray.push(object);
          }
        }
        return newArray;
      } else if (condition != null) {
        checked = [];
        while (checked.length < array.length) {
          object = this.sample(array);
          if (object && __indexOf.call(checked, object) < 0) {
            checked.push(object);
            if (condition(object)) {
              return object;
            }
          }
        }
      } else {
        if (this.empty(array)) {
          return null;
        }
        return array[this.randomInt(array.length)];
      }
    },
    contains: function(array, object) {
      return array.indexOf(object) >= 0;
    },
    remove: function(array, object) {
      var index;
      while (true) {
        index = array.indexOf(object);
        if (index === -1) {
          break;
        }
        array.splice(index, 1);
      }
      return array;
    },
    removeItems: function(array, objects) {
      var object, _i, _len;
      for (_i = 0, _len = objects.length; _i < _len; _i++) {
        object = objects[_i];
        this.remove(array, object);
      }
      return array;
    },
    shuffle: function(array) {
      return array.sort(function() {
        return 0.5 - Math.random();
      });
    },
    min: function(array, lambda, valueToo) {
      var minObject, minValue, object, value, _i, _len;
      if (lambda == null) {
        lambda = this.identityFunction;
      }
      if (valueToo == null) {
        valueToo = false;
      }
      if (this.empty(array)) {
        this.error("min: empty array");
      }
      if (this.isString(lambda)) {
        lambda = this.propertyFunction(lambda);
      }
      minValue = Infinity;
      minObject = null;
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        object = array[_i];
        value = lambda(object);
        if (value < minValue) {
          minValue = value;
          minObject = object;
        }
      }
      if (valueToo) {
        return [minObject, minValue];
      } else {
        return minObject;
      }
    },
    max: function(array, lambda, valueToo) {
      var maxObject, maxValue, object, value, _i, _len;
      if (lambda == null) {
        lambda = this.identityFunction;
      }
      if (valueToo == null) {
        valueToo = false;
      }
      if (this.empty(array)) {
        this.error("max: empty array");
      }
      if (this.isString(lambda)) {
        lambda = this.propertyFunction(lambda);
      }
      maxValue = -Infinity;
      maxObject = null;
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        object = array[_i];
        value = lambda(object);
        if (value > maxValue) {
          maxValue = value;
          maxObject = object;
        }
      }
      if (valueToo) {
        return [maxObject, maxValue];
      } else {
        return maxObject;
      }
    },
    sum: function(array, lambda) {
      var object, value, _i, _len;
      if (lambda == null) {
        lambda = this.identityFunction;
      }
      if (this.isString(lambda)) {
        lambda = this.propertyFunction(lambda);
      }
      value = 0;
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        object = array[_i];
        value += lambda(object);
      }
      return value;
    },
    average: function(array, lambda) {
      if (lambda == null) {
        lambda = this.identityFunction;
      }
      return this.sum(array, lambda) / array.length;
    },
    median: function(array) {
      var middle;
      if (array.sort != null) {
        array = this.clone(array);
      } else {
        array = this.typedToJS(array);
      }
      middle = (array.length - 1) / 2;
      this.sort(array);
      return (array[Math.floor(middle)] + array[Math.ceil(middle)]) / 2;
    },
    histogram: function(array, binSize, lambda) {
      var histogram, integer, object, value, _i, _j, _len, _len1;
      if (binSize == null) {
        binSize = 1;
      }
      if (lambda == null) {
        lambda = this.identityFunction;
      }
      if (this.isString(lambda)) {
        lambda = this.propertyFunction(lambda);
      }
      histogram = [];
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        object = array[_i];
        integer = Math.floor(lambda(object) / binSize);
        histogram[integer] || (histogram[integer] = 0);
        histogram[integer] += 1;
      }
      for (integer = _j = 0, _len1 = histogram.length; _j < _len1; integer = ++_j) {
        value = histogram[integer];
        if (value == null) {
          histogram[integer] = 0;
        }
      }
      return histogram;
    },
    sort: function(array, lambda) {
      if (lambda == null) {
        lambda = null;
      }
      if (this.isString(lambda)) {
        lambda = this.propertySortFunction(lambda);
      }
      return array._sort(lambda);
    },
    uniq: function(array) {
      var hash, index, _i, _ref;
      hash = {};
      for (index = _i = 0, _ref = array.length; 0 <= _ref ? _i < _ref : _i > _ref; index = 0 <= _ref ? ++_i : --_i) {
        if (hash[array[index]] === true) {
          array.splice(index, 1);
        }
        hash[array[index]] = true;
      }
      return array;
    },
    flatten: function(array) {
      return array.reduce(function(arrayA, arrayB) {
        if (!u.isArray(arrayA)) {
          arrayA = [arrayA];
        }
        return arrayA.concat(arrayB);
      });
    },
    normalize: function(array, low, high) {
      var max, min, newArray, number, scale, _i, _len;
      if (low == null) {
        low = 0;
      }
      if (high == null) {
        high = 1;
      }
      min = this.min(array);
      max = this.max(array);
      scale = 1 / (max - min);
      newArray = [];
      for (_i = 0, _len = array.length; _i < _len; _i++) {
        number = array[_i];
        newArray.push(this.linearInterpolate(low, high, scale * (number - min)));
      }
      return newArray;
    },
    normalizeInt: function(array, low, high) {
      var i, _i, _len, _ref, _results;
      _ref = this.normalize(array, low, high);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        _results.push(Math.round(i));
      }
      return _results;
    },
    normalize8: function(array) {
      return new Uint8ClampedArray(this.normalize(array, -.5, 255.5));
    },
    radiansToward: function(point1, point2, patches) {
      if (patches.isTorus) {
        return this.radiansTowardTorus(point1, point2, patches);
      } else {
        return this.radiansTowardEuclidian(point1, point2);
      }
    },
    radiansTowardEuclidian: function(point1, point2) {
      return Math.atan2(point2.y - point1.y, point2.x - point1.x);
    },
    radiansTowardTorus: function(point1, point2, patches) {
      var closest;
      closest = this.closestTorusPoint(point1, point2, patches.numX, patches.numY);
      return this.radiansTowardEuclidian(point1, closest);
    },
    inCone: function(heading, cone, radius, point1, point2, patches) {
      if (patches.isTorus) {
        return u.inConeTorus(heading, cone, radius, point1, point2, patches);
      } else {
        return u.inConeEuclidian(heading, cone, radius, point1, point2);
      }
    },
    inConeEuclidian: function(heading, cone, radius, point1, point2) {
      var angle;
      if (radius < this.distanceEuclidian(point1, point2)) {
        return false;
      }
      angle = this.radiansTowardEuclidian(point1, point2);
      return cone / 2 >= Math.abs(this.substractRadians(heading, angle));
    },
    inConeTorus: function(heading, cone, radius, point1, point2, patches) {
      var point, _i, _len, _ref;
      _ref = this.torus4Points(point1, point2, patches.numX, patches.numY);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        point = _ref[_i];
        if (this.inConeEuclidian(heading, cone, radius, point1, point)) {
          return true;
        }
      }
      return false;
    },
    distance: function(point1, point2, patches) {
      if (patches.isTorus) {
        return this.distanceTorus(point1, point2, patches);
      } else {
        return this.distanceEuclidian(point1, point2);
      }
    },
    distanceEuclidian: function(point1, point2) {
      var distanceX, distanceY;
      distanceX = point1.x - point2.x;
      distanceY = point1.y - point2.y;
      return Math.sqrt(distanceX * distanceX + distanceY * distanceY);
    },
    distanceTorus: function(point1, point2, patches) {
      var minX, minY, xDistance, yDistance;
      xDistance = Math.abs(point2.x - point1.x);
      yDistance = Math.abs(point2.y - point1.y);
      minX = Math.min(xDistance, patches.numX - xDistance);
      minY = Math.min(yDistance, patches.numY - yDistance);
      return Math.sqrt(minX * minX + minY * minY);
    },
    torus4Points: function(point1, point2, width, height) {
      var xReflected, yReflected, _ref;
      _ref = this.torusReflect(point1, point2, width, height), xReflected = _ref[0], yReflected = _ref[1];
      return [
        point2, {
          x: xReflected,
          y: point2.y
        }, {
          x: point2.x,
          y: yReflected
        }, {
          x: xReflected,
          y: yReflected
        }
      ];
    },
    closestTorusPoint: function(point1, point2, width, height) {
      var x, xReflected, y, yReflected, _ref;
      _ref = this.torusReflect(point1, point2, width, height), xReflected = _ref[0], yReflected = _ref[1];
      if (Math.abs(xReflected - point1.x) < Math.abs(point2.x - point1.x)) {
        x = xReflected;
      } else {
        x = point2.x;
      }
      if (Math.abs(yReflected - point1.y) < Math.abs(point2.y - point1.y)) {
        y = yReflected;
      } else {
        y = point2.y;
      }
      return {
        x: x,
        y: y
      };
    },
    torusReflect: function(point1, point2, width, height) {
      var xReflected, yReflected;
      if (point2.x < point1.x) {
        xReflected = point2.x + width;
      } else {
        xReflected = point2.x - width;
      }
      if (point2.y < point1.y) {
        yReflected = point2.y + height;
      } else {
        yReflected = point2.y - height;
      }
      return [xReflected, yReflected];
    },
    fileIndex: {},
    importImage: function(name, call) {
      var image;
      if (call == null) {
        call = function() {};
      }
      image = this.fileIndex[name];
      if (image != null) {
        if (image.isDone) {
          call(image);
        }
      } else {
        image = new Image();
        image.isDone = false;
        image.crossOrigin = "Anonymous";
        image.onload = function() {
          call(image);
          return image.isDone = true;
        };
        image.src = name;
        this.fileIndex[name] = image;
      }
      return image;
    },
    xhrLoadFile: function(name, method, type, call) {
      var xhr;
      if (method == null) {
        method = "GET";
      }
      if (type == null) {
        type = "text";
      }
      if (call == null) {
        call = function() {};
      }
      xhr = this.fileIndex[name];
      if (xhr != null) {
        if (xhr.isDone) {
          call(xhr.response);
        }
      } else {
        xhr = new XMLHttpRequest();
        xhr.isDone = false;
        xhr.open(method, name);
        xhr.responseType = type;
        xhr.onload = function() {
          call(xhr.response);
          return xhr.isDone = true;
        };
        this.fileIndex[name] = xhr;
        xhr.send();
      }
      return xhr;
    },
    filesLoaded: function(files) {
      var array, object;
      if (files == null) {
        files = this.fileIndex;
      }
      array = (function() {
        var _i, _len, _ref, _results;
        _ref = this.ownValues(files);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          object = _ref[_i];
          _results.push(object.isDone);
        }
        return _results;
      }).call(this);
      return array.reduce((function(valueA, valueB) {
        return valueA && valueB;
      }), true);
    },
    waitOnFiles: function(call, files) {
      if (files == null) {
        files = this.fileIndex;
      }
      return this.waitOn(((function(_this) {
        return function() {
          return _this.filesLoaded(files);
        };
      })(this)), call);
    },
    waitOn: function(done, call) {
      if (done()) {
        return call();
      } else {
        return setTimeout(((function(_this) {
          return function() {
            return _this.waitOn(done, call);
          };
        })(this)), 1000);
      }
    },
    cloneImage: function(image) {
      var newImage;
      newImage = new Image();
      newImage.src = image.src;
      return newImage;
    },
    imageToData: function(image, call, arrayType) {
      if (call == null) {
        call = this.pixelByte(0);
      }
      if (arrayType == null) {
        arrayType = Uint8ClampedArray;
      }
      return this.imageRowsToData(image, image.height, call, arrayType);
    },
    imageRowsToData: function(image, rowsPerSlice, call, arrayType) {
      var context, data, dataStart, i, idata, rows, rowsDone, _i, _ref;
      if (call == null) {
        call = this.pixelByte(0);
      }
      if (arrayType == null) {
        arrayType = Uint8ClampedArray;
      }
      rowsDone = 0;
      data = new arrayType(image.width * image.height);
      while (rowsDone < image.height) {
        rows = Math.min(image.height - rowsDone, rowsPerSlice);
        context = this.imageSliceToContext(image, 0, rowsDone, image.width, rows);
        idata = this.contextToImageData(context).data;
        dataStart = rowsDone * image.width;
        for (i = _i = 0, _ref = idata.length / 4; _i < _ref; i = _i += 1) {
          data[dataStart + i] = call(idata, 4 * i);
        }
        rowsDone += rows;
      }
      return data;
    },
    imageSliceToContext: function(image, sx, sy, sw, sh, context) {
      if (context != null) {
        context.canvas.width = sw;
        context.canvas.height = sh;
      } else {
        context = this.createContext(sw, sh);
      }
      context.drawImage(image, sx, sy, sw, sh, 0, 0, sw, sh);
      return context;
    },
    pixelByte: function(n) {
      return function(byte, i) {
        return byte[i + n];
      };
    },
    createCanvas: function(width, height) {
      var canvas;
      canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      return canvas;
    },
    createContext: function(width, height, contextType) {
      var canvas, _ref;
      if (contextType == null) {
        contextType = "2d";
      }
      canvas = this.createCanvas(width, height);
      if (contextType === "2d") {
        return canvas.getContext("2d");
      } else {
        return (_ref = canvas.getContext("webgl")) != null ? _ref : canvas.getContext("experimental-webgl");
      }
    },
    createLayer: function(div, width, height, z, context) {
      var element;
      if (context == null) {
        context = "2d";
      }
      if (context === "img") {
        element = context = new Image();
        context.width = width;
        context.height = height;
      } else {
        element = (context = this.createContext(width, height, context)).canvas;
      }
      this.insertLayer(div, element, width, height, z);
      return context;
    },
    insertLayer: function(div, element, w, h, z) {
      element.setAttribute('style', "position:absolute;top:0;left:0;width:" + w + ";height:" + h + ";z-index:" + z);
      return div.appendChild(element);
    },
    setContextSmoothing: function(context, smoothing) {
      context.imageSmoothingEnabled = smoothing;
      context.mozImageSmoothingEnabled = smoothing;
      context.oImageSmoothingEnabled = smoothing;
      return context.webkitImageSmoothingEnabled = smoothing;
    },
    setIdentity: function(context) {
      context.save();
      return context.setTransform(1, 0, 0, 1, 0, 0);
    },
    clearContext: function(context) {
      if (context.save != null) {
        this.setIdentity(context);
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        return context.restore();
      } else {
        context.clearColor(0, 0, 0, 0);
        return context.clear(context.COLOR_BUFFER_BIT | context.DEPTH_BUFFER_BIT);
      }
    },
    fillContext: function(context, color) {
      if (context.fillStyle != null) {
        this.setIdentity(context);
        context.fillStyle = this.colorString(color);
        context.fillRect(0, 0, context.canvas.width, context.canvas.height);
        return context.restore();
      } else {
        context.clearColor.apply(context, __slice.call(color).concat([1]));
        return context.clear(context.COLOR_BUFFER_BIT | context.DEPTH_BUFFER_BIT);
      }
    },
    contextDrawText: function(context, string, x, y, color, setIdentity) {
      if (color == null) {
        color = [0, 0, 0];
      }
      if (setIdentity == null) {
        setIdentity = true;
      }
      if (setIdentity) {
        this.setIdentity(context);
      }
      context.fillStyle = this.colorString(color);
      context.fillText(string, x, y);
      if (setIdentity) {
        return context.restore();
      }
    },
    contextTextParams: function(context, font, align, baseline) {
      if (align == null) {
        align = "center";
      }
      if (baseline == null) {
        baseline = "middle";
      }
      context.font = font;
      context.textAlign = align;
      return context.textBaseline = baseline;
    },
    elementTextParams: function(element, font, align, baseline) {
      if (align == null) {
        align = "center";
      }
      if (baseline == null) {
        baseline = "middle";
      }
      if (element.canvas != null) {
        element = element.canvas;
      }
      element.style.font = font;
      element.style.textAlign = align;
      return element.style.textBaseline = baseline;
    },
    contextToDataUrl: function(context) {
      return context.canvas.toDataURL("image/png");
    },
    contextToDataUrlImage: function(context, call) {
      var image;
      image = new Image();
      if (call != null) {
        image.onload = function() {
          return call(image);
        };
      }
      image.src = context.canvas.toDataURL("image/png");
      return image;
    },
    contextToImageData: function(context) {
      return context.getImageData(0, 0, context.canvas.width, context.canvas.height);
    },
    drawCenteredImage: function(context, image, radians, x, y, dx, dy) {
      context.translate(x, y);
      context.rotate(radians);
      return context.drawImage(image, -dx / 2, -dy / 2);
    },
    copyContext: function(context) {
      var newContext;
      newContext = this.createContext(context.canvas.width, context.canvas.height);
      newContext.drawImage(context.canvas, 0, 0);
      return newContext;
    },
    resizeContext: function(context, width, height, scale) {
      var newContext;
      if (scale == null) {
        scale = false;
      }
      newContext = this.copyContext(context);
      context.canvas.width = width;
      context.canvas.height = height;
      return context.drawImage(newContext.canvas, 0, 0);
    },
    linearInterpolate: function(low, high, scale) {
      return low + (high - low) * scale;
    },
    identityFunction: function(object) {
      return object;
    },
    propertyFunction: function(property) {
      return function(object) {
        return object[property];
      };
    },
    propertySortFunction: function(property) {
      return function(objectA, objectB) {
        if (objectA[property] < objectB[property]) {
          return -1;
        } else if (objectA[property] > objectB[property]) {
          return 1;
        } else {
          return 0;
        }
      };
    },
    typedToJS: function(typedArray) {
      var i, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = typedArray.length; _i < _len; _i++) {
        i = typedArray[_i];
        _results.push(i);
      }
      return _results;
    }
  };

  ABM.Set = (function(_super) {
    __extends(Set, _super);

    Set.asSet = function(a, setType) {
      var _ref;
      if (setType == null) {
        setType = ABM.Set;
      }
      a.__proto__ = (_ref = setType.prototype) != null ? _ref : setType.constructor.prototype;
      return a;
    };

    function Set(agentClass, name, mainSet) {
      Set.__super__.constructor.call(this, 0);
      this.agentClass = agentClass;
      this.name = name;
      this.mainSet = mainSet;
      if (this.mainSet == null) {
        this.breeds = [];
      }
      this.agentClass.prototype.breed = this;
      this.ownVariables = [];
      if (this.mainSet == null) {
        this.ID = 0;
      }
    }

    Set.prototype.create = function() {};

    Set.prototype.add = function(object) {
      if (this.mainSet != null) {
        this.mainSet.add(object);
      } else {
        object.id = this.ID++;
      }
      this.push(object);
      return object;
    };

    Set.prototype.remove = function(object) {
      if (this.mainSet != null) {
        u.remove(this.mainSet, object);
      }
      u.remove(this, object);
      return this;
    };

    Set.prototype.setDefault = function(name, value) {
      this.agentClass.prototype[name] = value;
      return this;
    };

    Set.prototype.own = function(vars) {
      var name, _i, _len, _ref;
      _ref = vars.split(" ");
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        name = _ref[_i];
        this.setDefault(name, null);
        this.ownVariables.push(name);
      }
      return this;
    };

    Set.prototype.setBreed = function(a) {
      var k, proto, v;
      u.remove(a.breed, a);
      this.push(a);
      proto = a.__proto__ = this.agentClass.prototype;
      for (k in a) {
        if (!__hasProp.call(a, k)) continue;
        v = a[k];
        if (proto[k] != null) {
          delete a[k];
        }
      }
      return a;
    };

    Set.prototype.exclude = function(breeds) {
      var o;
      breeds = breeds.split(" ");
      return this.asSet((function() {
        var _i, _len, _ref, _results;
        _results = [];
        for (_i = 0, _len = this.length; _i < _len; _i++) {
          o = this[_i];
          if (_ref = o.breed.name, __indexOf.call(breeds, _ref) < 0) {
            _results.push(o);
          }
        }
        return _results;
      }).call(this));
    };

    Set.prototype.floodFill = function(aset, fCandidate, fJoin, fCallback, fNeighbors, asetLast) {
      var floodFunc, _results;
      if (asetLast == null) {
        asetLast = [];
      }
      floodFunc = this.floodFillOnce(aset, fCandidate, fJoin, fCallback, fNeighbors, asetLast);
      _results = [];
      while (floodFunc) {
        _results.push(floodFunc = floodFunc());
      }
      return _results;
    };

    Set.prototype.floodFillOnce = function(aset, fCandidate, fJoin, fCallback, fNeighbors, asetLast) {
      var asetNext, n, p, stopEarly, _i, _j, _k, _len, _len1, _len2, _ref;
      if (asetLast == null) {
        asetLast = [];
      }
      for (_i = 0, _len = aset.length; _i < _len; _i++) {
        p = aset[_i];
        fJoin(p, asetLast);
      }
      asetNext = [];
      for (_j = 0, _len1 = aset.length; _j < _len1; _j++) {
        p = aset[_j];
        _ref = fNeighbors(p);
        for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
          n = _ref[_k];
          if (fCandidate(n, aset)) {
            if (asetNext.indexOf(n) < 0) {
              asetNext.push(n);
            }
          }
        }
      }
      stopEarly = fCallback && fCallback(aset, asetNext);
      if (stopEarly || asetNext.length === 0) {
        return null;
      } else {
        return (function(_this) {
          return function() {
            return _this.floodFillOnce(asetNext, fCandidate, fJoin, fCallback, fNeighbors, aset);
          };
        })(this);
      }
    };

    Set.prototype.uniq = function() {
      return u.uniq(this);
    };

    Set.prototype.asSet = function(a, setType) {
      if (setType == null) {
        setType = this;
      }
      return ABM.Set.asSet(a, setType);
    };

    Set.prototype.asOrderedSet = function(a) {
      return this.asSet(a).sort("id");
    };

    Set.prototype.toString = function() {
      var a;
      return "[" + ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = this.length; _i < _len; _i++) {
          a = this[_i];
          _results.push(a.toString());
        }
        return _results;
      }).call(this)).join(", ") + "]";
    };

    Set.prototype.getProp = function(prop) {
      var o, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        o = this[_i];
        _results.push(o[prop]);
      }
      return _results;
    };

    Set.prototype.getPropWith = function(prop, value) {
      var o;
      return this.asSet((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = this.length; _i < _len; _i++) {
          o = this[_i];
          if (o[prop] === value) {
            _results.push(o);
          }
        }
        return _results;
      }).call(this));
    };

    Set.prototype.setProp = function(prop, value) {
      var i, o, _i, _j, _len, _len1;
      if (u.isArray(value)) {
        for (i = _i = 0, _len = this.length; _i < _len; i = ++_i) {
          o = this[i];
          o[prop] = value[i];
        }
        return this;
      } else {
        for (_j = 0, _len1 = this.length; _j < _len1; _j++) {
          o = this[_j];
          o[prop] = value;
        }
        return this;
      }
    };

    Set.prototype.shuffle = function() {
      return u.shuffle(this);
    };

    Set.prototype.sort = function() {
      var options;
      options = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return u.sort.apply(u, [this].concat(__slice.call(options)));
    };

    Set.prototype.clone = function() {
      return this.asSet(u.clone(this));
    };

    Set.prototype.last = function() {
      return u.last(this);
    };

    Set.prototype.any = function() {
      return u.any(this);
    };

    Set.prototype.other = function(a) {
      var o;
      return this.asSet((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = this.length; _i < _len; _i++) {
          o = this[_i];
          if (o !== a) {
            _results.push(o);
          }
        }
        return _results;
      }).call(this));
    };

    Set.prototype.sample = function() {
      var options, random;
      options = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      random = u.sample.apply(u, [this].concat(__slice.call(options)));
      if (random && random.isArray) {
        return this.asSet(random);
      } else {
        return random;
      }
    };

    Set.prototype.min = function(f, valueToo) {
      if (valueToo == null) {
        valueToo = false;
      }
      return u.min(this, f, valueToo);
    };

    Set.prototype.max = function(f, valueToo) {
      if (valueToo == null) {
        valueToo = false;
      }
      return u.max(this, f, valueToo);
    };

    Set.prototype.draw = function(context) {
      var o, _i, _len;
      u.clearContext(context);
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        o = this[_i];
        if (!o.hidden) {
          o.draw(context);
        }
      }
      return null;
    };

    Set.prototype.show = function() {
      var o, _i, _len;
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        o = this[_i];
        o.hidden = false;
      }
      return this.draw(ABM.contexts[this.name]);
    };

    Set.prototype.hide = function() {
      var o, _i, _len;
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        o = this[_i];
        o.hidden = true;
      }
      return this.draw(ABM.contexts[this.name]);
    };

    Set.prototype.ask = function(f) {
      var o, _i, _len;
      if (u.isString(f)) {
        eval("f=function(o){return " + f + ";}");
      }
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        o = this[_i];
        f(o);
      }
      return this;
    };

    Set.prototype["with"] = function(f) {
      var o;
      if (u.isString(f)) {
        eval("f=function(o){return " + f + ";}");
      }
      return this.asSet((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = this.length; _i < _len; _i++) {
          o = this[_i];
          if (f(o)) {
            _results.push(o);
          }
        }
        return _results;
      }).call(this));
    };

    Set.prototype.inRadius = function(entity1, options) {
      var entity2, inner, _i, _len;
      inner = [];
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        entity2 = this[_i];
        if (entity1.distance(entity2) <= options.radius) {
          inner.push(entity2);
        }
      }
      return this.asSet(inner);
    };

    Set.prototype.inCone = function(entity1, options) {
      var entity2, inner, _i, _len;
      if (options.heading == null) {
        options.heading = entity1.heading;
      }
      inner = [];
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        entity2 = this[_i];
        if (u.inCone(options.heading, options.cone, options.radius, entity1, entity2, ABM.patches)) {
          inner.push(entity2);
        }
      }
      return this.asSet(inner);
    };

    return Set;

  })(Array);

  ABM.Agent = (function() {
    Agent.prototype.id = null;

    Agent.prototype.breed = null;

    Agent.prototype.x = 0;

    Agent.prototype.y = 0;

    Agent.prototype.patch = null;

    Agent.prototype.size = 1;

    Agent.prototype.color = null;

    Agent.prototype.shape = "default";

    Agent.prototype.hidden = false;

    Agent.prototype.label = null;

    Agent.prototype.labelColor = [0, 0, 0];

    Agent.prototype.labelOffset = [0, 0];

    Agent.prototype.penDown = false;

    Agent.prototype.penSize = 1;

    Agent.prototype.heading = null;

    Agent.prototype.sprite = null;

    Agent.prototype.cacheLinks = false;

    Agent.prototype.links = null;

    function Agent() {
      this.x = this.y = 0;
      if (this.color == null) {
        this.color = u.randomColor();
      }
      if (this.heading == null) {
        this.heading = u.randomFloat(Math.PI * 2);
      }
      if (this.cacheLinks) {
        this.links = [];
      }
      this.setXY(this.x, this.y);
    }

    Agent.prototype.fractionOfColor = function(color, fraction) {
      if (!this.hasOwnProperty("color")) {
        this.color = u.clone(this.color);
      }
      return u.fractionOfColor(color, fraction, this.color);
    };

    Agent.prototype.toString = function() {
      return "{id:" + this.id + " xy:" + (u.aToFixed([this.x, this.y])) + " c:" + this.color + " h: " + (this.heading.toFixed(2)) + "}";
    };

    Agent.prototype.setXY = function(x, y) {
      var drawing, oldPatch, x0, y0, _ref, _ref1;
      if (this.penDown) {
        _ref = [this.x, this.y], x0 = _ref[0], y0 = _ref[1];
      }
      _ref1 = ABM.patches.coord(x, y), this.x = _ref1[0], this.y = _ref1[1];
      oldPatch = this.patch;
      this.patch = ABM.patches.patch(this.x, this.y);
      if (oldPatch) {
        u.remove(oldPatch.agents, this);
      }
      this.patch.agents.push(this);
      if (this.penDown) {
        drawing = ABM.drawing;
        drawing.strokeStyle = u.colorString(this.color);
        drawing.lineWidth = ABM.patches.fromBits(this.penSize);
        drawing.beginPath();
        drawing.moveTo(x0, y0);
        drawing.lineTo(x, y);
        return drawing.stroke();
      }
    };

    Agent.prototype.losePosition = function() {
      u.remove(this.patch.agents, this);
      return this.patch = null;
    };

    Agent.prototype.moveTo = function(patch) {
      return this.setXY(patch.x, patch.y);
    };

    Agent.prototype.forward = function(d) {
      return this.setXY(this.x + d * Math.cos(this.heading), this.y + d * Math.sin(this.heading));
    };

    Agent.prototype.rotate = function(radians) {
      return this.heading = u.wrap(this.heading + radians, 0, Math.PI * 2);
    };

    Agent.prototype.draw = function(context) {
      var radians, shape, x, y, _ref;
      if (this.patch === null) {
        return;
      }
      shape = ABM.shapes[this.shape];
      radians = shape.rotate ? this.heading : 0;
      if ((this.sprite != null) || this.breed.useSprites) {
        if (this.sprite == null) {
          this.setSprite();
        }
        ABM.shapes.drawSprite(context, this.sprite, this.x, this.y, this.size, radians);
      } else {
        ABM.shapes.draw(context, shape, this.x, this.y, this.size, radians, this.color);
      }
      if (this.label != null) {
        _ref = ABM.patches.patchXYtoPixelXY(this.x, this.y), x = _ref[0], y = _ref[1];
        return u.contextDrawText(context, this.label, x + this.labelOffset[0], y + this.labelOffset[1], this.labelColor);
      }
    };

    Agent.prototype.setSprite = function(sprite) {
      if (sprite != null) {
        this.sprite = sprite;
        this.color = sprite.color;
        this.shape = sprite.shape;
        return this.size = sprite.size;
      } else {
        if (this.color == null) {
          this.color = u.randomColor;
        }
        return this.sprite = ABM.shapes.shapeToSprite(this.shape, this.color, this.size);
      }
    };

    Agent.prototype.stamp = function() {
      return this.draw(ABM.drawing);
    };

    Agent.prototype.closestTorusPoint = function(point) {
      return u.closestTorusPoint(this, point, ABM.patches.numX, ABM.patches.numY);
    };

    Agent.prototype.angleTowards = function(point) {
      return u.radiansToward(this, point, ABM.patches);
    };

    Agent.prototype.face = function(point) {
      return this.heading = this.angleTowards(point);
    };

    Agent.prototype.distance = function(point) {
      return u.distance(this, point, ABM.patches);
    };

    Agent.prototype.neighbors = function(options) {
      var agent, neighbors, patch, square, _i, _j, _len, _len1, _ref, _ref1;
      if (options == null) {
        options = 1;
      }
      if (options.radius) {
        square = this.neighbors(options.radius);
        if (options.cone) {
          neighbors = square.inCone(this, options);
        } else {
          neighbors = square.inRadius(this, options);
        }
      } else {
        neighbors = this.breed.asSet([]);
        if (this.patch) {
          _ref = this.patch.neighbors(options);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            patch = _ref[_i];
            _ref1 = patch.agents;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              agent = _ref1[_j];
              if (agent !== this) {
                neighbors.push(agent);
              }
            }
          }
        }
      }
      return neighbors;
    };

    Agent.prototype.die = function() {
      var l, _i, _len, _ref;
      this.breed.remove(this);
      _ref = this.myLinks();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        l = _ref[_i];
        l.die();
      }
      if (this.patch.agents != null) {
        u.remove(this.patch.agents, this);
      }
      return null;
    };

    Agent.prototype.hatch = function(num, breed, init) {
      if (num == null) {
        num = 1;
      }
      if (breed == null) {
        breed = ABM.agents;
      }
      if (init == null) {
        init = function() {};
      }
      return breed.create(num, (function(_this) {
        return function(a) {
          var k, v;
          a.setXY(_this.x, _this.y);
          for (k in _this) {
            if (!__hasProp.call(_this, k)) continue;
            v = _this[k];
            if (k !== "id") {
              a[k] = v;
            }
          }
          init(a);
          return a;
        };
      })(this));
    };

    Agent.prototype.otherEnd = function(l) {
      if (l.end1 === this) {
        return l.end2;
      } else {
        return l.end1;
      }
    };

    Agent.prototype.myLinks = function() {
      var l, _ref;
      return (_ref = this.links) != null ? _ref : (function() {
        var _i, _len, _ref1, _results;
        _ref1 = ABM.links;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          l = _ref1[_i];
          if ((l.end1 === this) || (l.end2 === this)) {
            _results.push(l);
          }
        }
        return _results;
      }).call(this);
    };

    Agent.prototype.linkNeighbors = function() {
      var l, _i, _len, _ref, _results;
      _ref = this.myLinks();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        l = _ref[_i];
        _results.push(this.otherEnd(l));
      }
      return _results;
    };

    Agent.prototype.myInLinks = function() {
      var l, _i, _len, _ref, _results;
      _ref = this.myLinks();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        l = _ref[_i];
        if (l.end2 === this) {
          _results.push(l);
        }
      }
      return _results;
    };

    Agent.prototype.inLinkNeighbors = function() {
      var l, _i, _len, _ref, _results;
      _ref = this.myLinks();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        l = _ref[_i];
        if (l.end2 === this) {
          _results.push(l.end1);
        }
      }
      return _results;
    };

    Agent.prototype.myOutLinks = function() {
      var l, _i, _len, _ref, _results;
      _ref = this.myLinks();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        l = _ref[_i];
        if (l.end1 === this) {
          _results.push(l);
        }
      }
      return _results;
    };

    Agent.prototype.outLinkNeighbors = function() {
      var l, _i, _len, _ref, _results;
      _ref = this.myLinks();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        l = _ref[_i];
        if (l.end1 === this) {
          _results.push(l.end2);
        }
      }
      return _results;
    };

    return Agent;

  })();

  ABM.Agents = (function(_super) {
    __extends(Agents, _super);

    function Agents() {
      Agents.__super__.constructor.apply(this, arguments);
      this.useSprites = false;
    }

    Agents.prototype.cacheLinks = function() {
      return this.agentClass.prototype.cacheLinks = true;
    };

    Agents.prototype.setUseSprites = function(useSprites) {
      this.useSprites = useSprites != null ? useSprites : true;
    };

    Agents.prototype["in"] = function(array) {
      var o;
      return this.asSet((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = array.length; _i < _len; _i++) {
          o = array[_i];
          if (o.breed === this) {
            _results.push(o);
          }
        }
        return _results;
      }).call(this));
    };

    Agents.prototype.create = function(num, init) {
      var i, _i, _results;
      if (init == null) {
        init = function() {};
      }
      _results = [];
      for (i = _i = 1; _i <= num; i = _i += 1) {
        _results.push((function(o) {
          init(o);
          return o;
        })(this.add(new this.agentClass)));
      }
      return _results;
    };

    Agents.prototype.clear = function() {
      while (this.any()) {
        this.last().die();
      }
      return null;
    };

    Agents.prototype.neighboring = function(agent, rangeOptions) {
      var array;
      array = agent.neighbors(rangeOptions);
      if (this.mainSet != null) {
        return this["in"](array);
      } else {
        return this.asSet(array);
      }
    };

    return Agents;

  })(ABM.Set);

  ABM.Animator = (function() {
    function Animator(model, rate, multiStep) {
      this.model = model;
      this.rate = rate != null ? rate : 30;
      this.multiStep = multiStep != null ? multiStep : model.world.isHeadless;
      this.animateDraws = __bind(this.animateDraws, this);
      this.animateSteps = __bind(this.animateSteps, this);
      this.isHeadless = model.world.isHeadless;
      this.reset();
    }

    Animator.prototype.setRate = function(rate, multiStep) {
      this.rate = rate;
      this.multiStep = multiStep != null ? multiStep : this.isHeadless;
      return this.resetTimes();
    };

    Animator.prototype.start = function() {
      if (!this.stopped) {
        return;
      }
      this.resetTimes();
      this.stopped = false;
      return this.animate();
    };

    Animator.prototype.stop = function() {
      this.stopped = true;
      if (this.animatorHandle != null) {
        cancelAnimFrame(this.animatorHandle);
      }
      if (this.timeoutHandle != null) {
        clearTimeout(this.timeoutHandle);
      }
      if (this.intervalHandle != null) {
        clearInterval(this.intervalHandle);
      }
      return this.animatorHandle = this.timerHandle = this.intervalHandle = null;
    };

    Animator.prototype.resetTimes = function() {
      this.startMS = this.now();
      this.startTick = this.ticks;
      return this.startDraw = this.draws;
    };

    Animator.prototype.reset = function() {
      this.stop();
      return this.ticks = this.draws = 0;
    };

    Animator.prototype.step = function() {
      this.ticks++;
      return this.model.step();
    };

    Animator.prototype.draw = function() {
      this.draws++;
      return this.model.draw();
    };

    Animator.prototype.once = function() {
      this.step();
      return this.draw();
    };

    Animator.prototype.now = function() {
      return (typeof performance !== "undefined" && performance !== null ? performance : Date).now();
    };

    Animator.prototype.ms = function() {
      return this.now() - this.startMS;
    };

    Animator.prototype.ticksPerSec = function() {
      var elapsed;
      elapsed = this.ticks - this.startTick;
      if (elapsed === 0) {
        return 0;
      } else {
        return Math.round(elapsed * 1000 / this.ms());
      }
    };

    Animator.prototype.drawsPerSec = function() {
      var elapsed;
      elapsed = this.draws - this.startDraw;
      if (elapsed === 0) {
        return 0;
      } else {
        return Math.round(elapsed * 1000 / this.ms());
      }
    };

    Animator.prototype.toString = function() {
      return ("ticks: " + this.ticks + ", draws: " + this.draws + ", rate: " + this.rate + " ") + ("tps/dps: " + (this.ticksPerSec()) + "/" + (this.drawsPerSec()));
    };

    Animator.prototype.animateSteps = function() {
      this.step();
      if (!this.stopped) {
        return this.timeoutHandle = setTimeout(this.animateSteps, 10);
      }
    };

    Animator.prototype.animateDraws = function() {
      if (this.isHeadless) {
        if (this.ticksPerSec() < this.rate) {
          this.step();
        }
      } else if (this.drawsPerSec() < this.rate) {
        if (!this.multiStep) {
          this.step();
        }
        this.draw();
      }
      if (!this.stopped) {
        return this.animatorHandle = requestAnimFrame(this.animateDraws);
      }
    };

    Animator.prototype.animate = function() {
      if (this.multiStep) {
        this.animateSteps();
      }
      if (!(this.isHeadless && this.multiStep)) {
        return this.animateDraws();
      }
    };

    return Animator;

  })();

  ABM.Link = (function() {
    Link.prototype.id = null;

    Link.prototype.breed = null;

    Link.prototype.end1 = null;

    Link.prototype.end2 = null;

    Link.prototype.color = [130, 130, 130];

    Link.prototype.thickness = 2;

    Link.prototype.hidden = false;

    Link.prototype.label = null;

    Link.prototype.labelColor = [0, 0, 0];

    Link.prototype.labelOffset = [0, 0];

    function Link(end1, end2) {
      this.end1 = end1;
      this.end2 = end2;
      if (this.end1.links != null) {
        this.end1.links.push(this);
        this.end2.links.push(this);
      }
    }

    Link.prototype.draw = function(context) {
      var pt, x, x0, y, y0, _ref;
      context.save();
      context.strokeStyle = u.colorString(this.color);
      context.lineWidth = ABM.patches.fromBits(this.thickness);
      context.beginPath();
      if (!ABM.patches.isTorus) {
        context.moveTo(this.end1.x, this.end1.y);
        context.lineTo(this.end2.x, this.end2.y);
      } else {
        pt = this.end1.closestTorusPoint(this.end2);
        context.moveTo(this.end1.x, this.end1.y);
        context.lineTo.apply(context, pt);
        if (pt[0] !== this.end2.x || pt[1] !== this.end2.y) {
          pt = this.end2.closestTorusPoint(this.end1);
          context.moveTo(this.end2.x, this.end2.y);
          context.lineTo.apply(context, pt);
        }
      }
      context.closePath();
      context.stroke();
      context.restore();
      if (this.label != null) {
        x0 = u.linearInterpolate(this.end1.x, this.end2.x, .5);
        y0 = u.linearInterpolate(this.end1.y, this.end2.y, .5);
        _ref = ABM.patches.patchXYtoPixelXY(x0, y0), x = _ref[0], y = _ref[1];
        return u.contextDrawText(context, this.label, x + this.labelOffset[0], y + this.labelOffset[1], this.labelColor);
      }
    };

    Link.prototype.die = function() {
      this.breed.remove(this);
      if (this.end1.links != null) {
        u.remove(this.end1.links, this);
      }
      if (this.end2.links != null) {
        u.remove(this.end2.links, this);
      }
      return null;
    };

    Link.prototype.bothEnds = function() {
      return [this.end1, this.end2];
    };

    Link.prototype.length = function() {
      return this.end1.distance(this.end2);
    };

    Link.prototype.otherEnd = function(a) {
      if (this.end1 === a) {
        return this.end2;
      } else {
        return this.end1;
      }
    };

    return Link;

  })();

  ABM.Links = (function(_super) {
    __extends(Links, _super);

    function Links() {
      Links.__super__.constructor.apply(this, arguments);
    }

    Links.prototype.create = function(from, to, init) {
      var a, _i, _len, _results;
      if (init == null) {
        init = function() {};
      }
      if (to.length == null) {
        to = [to];
      }
      _results = [];
      for (_i = 0, _len = to.length; _i < _len; _i++) {
        a = to[_i];
        _results.push((function(o) {
          init(o);
          return o;
        })(this.add(new this.agentClass(from, a))));
      }
      return _results;
    };

    Links.prototype.clear = function() {
      while (this.any()) {
        this.last().die();
      }
      return null;
    };

    Links.prototype.allEnds = function() {
      var l, n, _i, _len;
      n = this.asSet([]);
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        l = this[_i];
        n.push(l.end1, l.end2);
      }
      return n;
    };

    Links.prototype.nodes = function() {
      return this.allEnds().uniq();
    };

    Links.prototype.layoutCircle = function(list, radius, startAngle, direction) {
      var a, dTheta, i, _i, _len;
      if (startAngle == null) {
        startAngle = Math.PI / 2;
      }
      if (direction == null) {
        direction = -1;
      }
      dTheta = 2 * Math.PI / list.length;
      for (i = _i = 0, _len = list.length; _i < _len; i = ++_i) {
        a = list[i];
        a.setXY(0, 0);
        a.heading = startAngle + direction * dTheta * i;
        a.forward(radius);
      }
      return null;
    };

    return Links;

  })(ABM.Set);

  ABM.models = {};

  ABM.Model = (function() {
    Model.prototype.contextsInit = {
      patches: {
        z: 10,
        context: "2d"
      },
      drawing: {
        z: 20,
        context: "2d"
      },
      links: {
        z: 30,
        context: "2d"
      },
      agents: {
        z: 40,
        context: "2d"
      },
      spotlight: {
        z: 50,
        context: "2d"
      }
    };

    function Model(divOrOptions, size, minX, maxX, minY, maxY, isTorus, hasNeighbors, isHeadless) {
      var context, div, k, v, _ref;
      if (size == null) {
        size = 13;
      }
      if (minX == null) {
        minX = -16;
      }
      if (maxX == null) {
        maxX = 16;
      }
      if (minY == null) {
        minY = -16;
      }
      if (maxY == null) {
        maxY = 16;
      }
      if (isTorus == null) {
        isTorus = false;
      }
      if (hasNeighbors == null) {
        hasNeighbors = true;
      }
      if (isHeadless == null) {
        isHeadless = false;
      }
      ABM.model = this;
      if (typeof divOrOptions === 'string') {
        div = divOrOptions;
        this.setWorldDeprecated(size, minX, maxX, minY, maxY, isTorus, hasNeighbors, isHeadless);
      } else {
        div = divOrOptions.div;
        isHeadless = divOrOptions.isHeadless = (divOrOptions.isHeadless != null) || (div == null);
        this.setWorld(divOrOptions);
      }
      this.contexts = ABM.contexts = {};
      if (!isHeadless) {
        (this.div = document.getElementById(div)).setAttribute('style', "position:relative; width:" + this.world.pxWidth + "px; height:" + this.world.pxHeight + "px");
        _ref = this.contextsInit;
        for (k in _ref) {
          if (!__hasProp.call(_ref, k)) continue;
          v = _ref[k];
          this.contexts[k] = context = u.createLayer(this.div, this.world.pxWidth, this.world.pxHeight, v.z, v.context);
          if (context.canvas != null) {
            this.setContextTransform(context);
          }
          if (context.canvas != null) {
            context.canvas.style.pointerEvents = 'none';
          }
          u.elementTextParams(context, "10px sans-serif", "center", "middle");
        }
        this.drawing = ABM.drawing = this.contexts.drawing;
        this.drawing.clear = (function(_this) {
          return function() {
            return u.clearContext(_this.drawing);
          };
        })(this);
        this.contexts.spotlight.globalCompositeOperation = "xor";
      }
      this.animator = new ABM.Animator(this);
      this.refreshLinks = this.refreshAgents = this.refreshPatches = true;
      this.patchBreeds('patches');
      this.agentBreeds('agents');
      this.linkBreeds('links');
      this.debugging = false;
      this.modelReady = false;
      this.globalNames = null;
      this.globalNames = u.ownKeys(this);
      this.globalNames.set = false;
      this.startup();
      u.waitOnFiles((function(_this) {
        return function() {
          _this.modelReady = true;
          _this.setup();
          if (!_this.globalNames.set) {
            return _this.globals();
          }
        };
      })(this));
    }

    Model.prototype.setWorld = function(options) {
      var defaults, key, value;
      defaults = {
        size: 13,
        minX: -16,
        maxX: 16,
        minY: -16,
        maxY: 16,
        isTorus: false,
        hasNeighbors: true,
        isHeadless: false
      };
      for (key in defaults) {
        if (!__hasProp.call(defaults, key)) continue;
        value = defaults[key];
        if (options[key] == null) {
          options[key] = value;
        }
      }
      ABM.world = this.world = {};
      for (key in options) {
        if (!__hasProp.call(options, key)) continue;
        value = options[key];
        this.world[key] = value;
      }
      this.world.numX = this.world.maxX - this.world.minX + 1;
      this.world.numY = this.world.maxY - this.world.minY + 1;
      this.world.pxWidth = this.world.numX * this.world.size;
      this.world.pxHeight = this.world.numY * this.world.size;
      this.world.minXcor = this.world.minX - .5;
      this.world.maxXcor = this.world.maxX + .5;
      this.world.minYcor = this.world.minY - .5;
      return this.world.maxYcor = this.world.maxY + .5;
    };

    Model.prototype.setWorldDeprecated = function(size, minX, maxX, minY, maxY, isTorus, hasNeighbors, isHeadless) {
      var maxXcor, maxYcor, minXcor, minYcor, numX, numY, pxHeight, pxWidth;
      numX = maxX - minX + 1;
      numY = maxY - minY + 1;
      pxWidth = numX * size;
      pxHeight = numY * size;
      minXcor = minX - .5;
      maxXcor = maxX + .5;
      minYcor = minY - .5;
      maxYcor = maxY + .5;
      return ABM.world = this.world = {
        size: size,
        minX: minX,
        maxX: maxX,
        minY: minY,
        maxY: maxY,
        minXcor: minXcor,
        maxXcor: maxXcor,
        minYcor: minYcor,
        maxYcor: maxYcor,
        numX: numX,
        numY: numY,
        pxWidth: pxWidth,
        pxHeight: pxHeight,
        isTorus: isTorus,
        hasNeighbors: hasNeighbors,
        isHeadless: isHeadless
      };
    };

    Model.prototype.setContextTransform = function(context) {
      context.canvas.width = this.world.pxWidth;
      context.canvas.height = this.world.pxHeight;
      context.save();
      context.scale(this.world.size, -this.world.size);
      return context.translate(-this.world.minXcor, -this.world.maxYcor);
    };

    Model.prototype.globals = function(globalNames) {
      if (globalNames != null) {
        this.globalNames = globalNames;
        return this.globalNames.set = true;
      } else {
        return this.globalNames = u.removeItems(u.ownKeys(this), this.globalNames);
      }
    };

    Model.prototype.setFastPatches = function() {
      return this.patches.usePixels();
    };

    Model.prototype.setMonochromePatches = function() {
      return this.patches.monochrome = true;
    };

    Model.prototype.setCacheMyLinks = function() {
      return this.agents.cacheLinks();
    };

    Model.prototype.startup = function() {};

    Model.prototype.setup = function() {};

    Model.prototype.step = function() {};

    Model.prototype.start = function() {
      u.waitOn(((function(_this) {
        return function() {
          return _this.modelReady;
        };
      })(this)), ((function(_this) {
        return function() {
          return _this.animator.start();
        };
      })(this)));
      this.isRunning = true;
      return this;
    };

    Model.prototype.stop = function() {
      this.animator.stop();
      this.isRunning = false;
      return this;
    };

    Model.prototype.toggle = function() {
      if (this.isRunning) {
        return this.stop();
      } else {
        return this.start();
      }
    };

    Model.prototype.once = function() {
      if (!this.animator.stopped) {
        this.stop();
      }
      this.animator.once();
      return this;
    };

    Model.prototype.draw = function(force) {
      if (force == null) {
        force = this.animator.stopped;
      }
      if (force || this.refreshPatches || this.animator.draws === 1) {
        this.patches.draw(this.contexts.patches);
      }
      if (force || this.refreshLinks || this.animator.draws === 1) {
        this.links.draw(this.contexts.links);
      }
      if (force || this.refreshAgents || this.animator.draws === 1) {
        this.agents.draw(this.contexts.agents);
      }
      if (this.spotlightAgent != null) {
        return this.drawSpotlight(this.spotlightAgent, this.contexts.spotlight);
      }
    };

    Model.prototype.setSpotlight = function(spotlightAgent) {
      this.spotlightAgent = spotlightAgent;
      if (this.spotlightAgent == null) {
        return u.clearContext(this.contexts.spotlight);
      }
    };

    Model.prototype.drawSpotlight = function(agent, context) {
      u.clearContext(context);
      u.fillContext(context, [0, 0, 0, 0.6]);
      context.beginPath();
      context.arc(agent.x, agent.y, 3, 0, 2 * Math.PI, false);
      return context.fill();
    };

    Model.prototype.createBreeds = function(list, type, agentClass, breedSet) {
      var Breed, breed, breedClass, breeds, resetType, string, _i, _len;
      if (u.isString(list)) {
        list = list.split(" ");
      }
      breeds = [];
      breeds.classes = {};
      breeds.sets = {};
      resetType = false;
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        string = list[_i];
        if (string === type) {
          ABM[type] = this[type] = new breedSet(agentClass, string);
        } else {
          breedClass = Breed = (function(_super) {
            __extends(Breed, _super);

            function Breed() {
              return Breed.__super__.constructor.apply(this, arguments);
            }

            return Breed;

          })(agentClass);
          breed = this[string] = new breedSet(breedClass, string, agentClass.prototype.breed);
          breeds.push(breed);
          breeds.sets[string] = breed;
          breeds.classes["" + string + "Class"] = breedClass;
        }
      }
      return this[type].breeds = breeds;
    };

    Model.prototype.patchBreeds = function(list, agentClass, breedSet) {
      if (agentClass == null) {
        agentClass = ABM.Patch;
      }
      if (breedSet == null) {
        breedSet = ABM.Patches;
      }
      return this.createBreeds(list, 'patches', agentClass, breedSet);
    };

    Model.prototype.agentBreeds = function(list, agentClass, breedSet) {
      if (agentClass == null) {
        agentClass = ABM.Agent;
      }
      if (breedSet == null) {
        breedSet = ABM.Agents;
      }
      return this.createBreeds(list, 'agents', agentClass, breedSet);
    };

    Model.prototype.linkBreeds = function(list, agentClass, breedSet) {
      if (agentClass == null) {
        agentClass = ABM.Link;
      }
      if (breedSet == null) {
        breedSet = ABM.Links;
      }
      return this.createBreeds(list, 'links', agentClass, breedSet);
    };

    Model.prototype.asSet = function(a, setType) {
      if (setType == null) {
        setType = ABM.Set;
      }
      return ABM.Set.asSet(a, setType);
    };

    Model.prototype.debug = function(debugging) {
      this.debugging = debugging != null ? debugging : true;
      u.waitOn(((function(_this) {
        return function() {
          return _this.modelReady;
        };
      })(this)), ((function(_this) {
        return function() {
          return _this.setRootVars();
        };
      })(this)));
      return this;
    };

    Model.prototype.setRootVars = function() {
      root.ps = this.patches;
      root.p0 = this.patches[0];
      root.as = this.agents;
      root.a0 = this.agents[0];
      root.ls = this.links;
      root.l0 = this.links[0];
      root.dr = this.drawing;
      root.u = ABM.util;
      root.cx = this.contexts;
      root.an = this.animator;
      root.gl = this.globals;
      root.dv = this.div;
      root.root = root;
      return root.app = this;
    };

    return Model;

  })();

  ABM.Patch = (function() {
    Patch.prototype.id = null;

    Patch.prototype.breed = null;

    Patch.prototype.x = null;

    Patch.prototype.y = null;

    Patch.prototype.color = [0, 0, 0];

    Patch.prototype.hidden = false;

    Patch.prototype.label = null;

    Patch.prototype.labelColor = [0, 0, 0];

    Patch.prototype.labelOffset = [0, 0];

    Patch.prototype.agents = null;

    function Patch(x, y) {
      this.x = x;
      this.y = y;
      this.neighborsCache = {};
      this.agents = [];
    }

    Patch.prototype.toString = function() {
      return "{id:" + this.id + " xy:" + [this.x, this.y] + " c:" + this.color + "}";
    };

    Patch.prototype.fractionOfColor = function(color, fraction) {
      if (!this.hasOwnProperty("color")) {
        this.color = u.clone(this.color);
      }
      return u.fractionOfColor(color, fraction, this.color);
    };

    Patch.prototype.draw = function(context) {
      var x, y, _ref;
      context.fillStyle = u.colorString(this.color);
      context.fillRect(this.x - .5, this.y - .5, 1, 1);
      if (this.label != null) {
        _ref = this.breed.patchXYtoPixelXY(this.x, this.y), x = _ref[0], y = _ref[1];
        return u.contextDrawText(context, this.label, x + this.labelOffset[0], y + this.labelOffset[1], this.labelColor);
      }
    };

    Patch.prototype.empty = function() {
      return u.empty(this.agents);
    };

    Patch.prototype.isOnEdge = function() {
      return this.x === this.breed.minX || this.x === this.breed.maxX || this.y === this.breed.minY || this.y === this.breed.maxY;
    };

    Patch.prototype.sprout = function(number, breed, init) {
      if (number == null) {
        number = 1;
      }
      if (breed == null) {
        breed = ABM.agents;
      }
      if (init == null) {
        init = function() {};
      }
      return breed.create(number, (function(_this) {
        return function(agent) {
          agent.setXY(_this.x, _this.y);
          init(agent);
          return agent;
        };
      })(this));
    };

    Patch.prototype.distance = function(point) {
      return u.distance(this, point, ABM.patches);
    };

    Patch.prototype.neighbors = function(options) {
      var cacheKey, neighbors, square;
      if (options == null) {
        options = 1;
      }
      cacheKey = JSON.stringify(options);
      neighbors = this.neighborsCache[cacheKey];
      if (neighbors == null) {
        if (options.radius) {
          square = this.neighbors(options.radius);
          if (options.cone) {
            neighbors = square.inCone(this, options);
          } else {
            neighbors = square.inRadius(this, options);
          }
        } else if (options.diamond) {
          neighbors = this.diamondNeighbors(options.diamond, options);
        } else {
          neighbors = this.breed.patchRectangle(this, options, options);
        }
        this.neighborsCache[cacheKey] = neighbors;
      }
      return neighbors;
    };

    Patch.prototype.diamondNeighbors = function(range) {
      var column, counter, diamond, distanceColumn, distanceRow, neighbor, neighbors, row, span, _i, _len;
      neighbors = this.breed.patchRectangleNullPadded(this, range, range, true);
      diamond = [];
      counter = 0;
      row = 0;
      column = -1;
      span = range * 2 + 1;
      for (_i = 0, _len = neighbors.length; _i < _len; _i++) {
        neighbor = neighbors[_i];
        row = counter % span;
        if (row === 0) {
          column += 1;
        }
        distanceColumn = Math.abs(column - range);
        distanceRow = Math.abs(row - range);
        if (distanceRow + distanceColumn <= range && distanceRow + distanceColumn !== 0) {
          diamond.push(neighbor);
        }
        counter += 1;
      }
      u.remove(diamond, null);
      return this.breed.asSet(diamond);
    };

    return Patch;

  })();

  ABM.Patches = (function(_super) {
    __extends(Patches, _super);

    function Patches() {
      var key, value, _ref;
      Patches.__super__.constructor.apply(this, arguments);
      this.monochrome = false;
      _ref = ABM.world;
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        value = _ref[key];
        this[key] = value;
      }
    }

    Patches.prototype.create = function() {
      var x, y, _i, _j, _ref, _ref1, _ref2, _ref3;
      for (y = _i = _ref = this.maxY, _ref1 = this.minY; _i >= _ref1; y = _i += -1) {
        for (x = _j = _ref2 = this.minX, _ref3 = this.maxX; _j <= _ref3; x = _j += 1) {
          this.add(new this.agentClass(x, y));
        }
      }
      if (!this.isHeadless) {
        this.setPixels();
      }
      return this;
    };

    Patches.prototype.usePixels = function(drawWithPixels) {
      var context;
      this.drawWithPixels = drawWithPixels != null ? drawWithPixels : true;
      context = ABM.contexts.patches;
      return u.setContextSmoothing(context, !this.drawWithPixels);
    };

    Patches.prototype.setPixels = function() {
      if (this.size === 1) {
        this.usePixels();
        this.pixelsContext = ABM.contexts.patches;
      } else {
        this.pixelsContext = u.createContext(this.numX, this.numY);
      }
      this.pixelsImageData = this.pixelsContext.getImageData(0, 0, this.numX, this.numY);
      this.pixelsData = this.pixelsImageData.data;
      if (this.pixelsData instanceof Uint8Array) {
        this.pixelsData32 = new Uint32Array(this.pixelsData.buffer);
        return this.pixelsAreLittleEndian = u.isLittleEndian();
      }
    };

    Patches.prototype.draw = function(context) {
      if (this.monochrome) {
        return u.fillContext(context, this.agentClass.prototype.color);
      } else if (this.drawWithPixels) {
        return this.drawScaledPixels(context);
      } else {
        return Patches.__super__.draw.call(this, context);
      }
    };

    Patches.prototype.patchIndex = function(x, y) {
      return x - this.minX + this.numX * (this.maxY - y);
    };

    Patches.prototype.patchXY = function(x, y) {
      return this[this.patchIndex(x, y)];
    };

    Patches.prototype.clamp = function(x, y) {
      return [u.clamp(x, this.minXcor, this.maxXcor), u.clamp(y, this.minYcor, this.maxYcor)];
    };

    Patches.prototype.wrap = function(x, y) {
      return [u.wrap(x, this.minXcor, this.maxXcor), u.wrap(y, this.minYcor, this.maxYcor)];
    };

    Patches.prototype.coord = function(x, y) {
      if (this.isTorus) {
        return this.wrap(x, y);
      } else {
        return this.clamp(x, y);
      }
    };

    Patches.prototype.isOnWorld = function(x, y) {
      return this.isTorus || ((this.minXcor <= x && x <= this.maxXcor) && (this.minYcor <= y && y <= this.maxYcor));
    };

    Patches.prototype.patch = function(x, y) {
      var _ref;
      _ref = this.coord(x, y), x = _ref[0], y = _ref[1];
      x = u.clamp(Math.round(x), this.minX, this.maxX);
      y = u.clamp(Math.round(y), this.minY, this.maxY);
      return this.patchXY(x, y);
    };

    Patches.prototype.randomPoint = function() {
      return [u.randomFloat(this.minXcor, this.maxXcor), u.randomFloat(this.minYcor, this.maxYcor)];
    };

    Patches.prototype.toBits = function(patch) {
      return patch * this.size;
    };

    Patches.prototype.fromBits = function(b) {
      return b / this.size;
    };

    Patches.prototype.patchRectangle = function(patch, dx, dy, meToo) {
      var rectangle;
      if (meToo == null) {
        meToo = false;
      }
      rectangle = this.patchRectangleNullPadded(patch, dx, dy, meToo);
      return u.remove(rectangle, null);
    };

    Patches.prototype.patchRectangleNullPadded = function(patch, dx, dy, meToo) {
      var nextPatch, rectangle, x, y, _i, _j, _ref, _ref1, _ref2, _ref3;
      if (meToo == null) {
        meToo = false;
      }
      rectangle = [];
      for (y = _i = _ref = patch.y - dy, _ref1 = patch.y + dy; _i <= _ref1; y = _i += 1) {
        for (x = _j = _ref2 = patch.x - dx, _ref3 = patch.x + dx; _j <= _ref3; x = _j += 1) {
          nextPatch = null;
          if (this.isTorus) {
            if (x < this.minX) {
              x += this.numX;
            }
            if (x > this.maxX) {
              x -= this.numX;
            }
            if (y < this.minY) {
              y += this.numY;
            }
            if (y > this.maxY) {
              y -= this.numY;
            }
            nextPatch = this.patchXY(x, y);
          } else if (x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY) {
            nextPatch = this.patchXY(x, y);
          }
          if (meToo || patch !== nextPatch) {
            rectangle.push(nextPatch);
          }
        }
      }
      return this.asSet(rectangle);
    };

    Patches.prototype.importDrawing = function(imageSrc, f) {
      return u.importImage(imageSrc, (function(_this) {
        return function(img) {
          _this.installDrawing(img);
          if (f != null) {
            return f();
          }
        };
      })(this));
    };

    Patches.prototype.installDrawing = function(img, context) {
      if (context == null) {
        context = ABM.contexts.drawing;
      }
      u.setIdentity(context);
      context.drawImage(img, 0, 0, context.canvas.width, context.canvas.height);
      return context.restore();
    };

    Patches.prototype.pixelByteIndex = function(patch) {
      return 4 * patch.id;
    };

    Patches.prototype.pixelWordIndex = function(patch) {
      return patch.id;
    };

    Patches.prototype.pixelXYtoPatchXY = function(x, y) {
      return [this.minXcor + (x / this.size), this.maxYcor - (y / this.size)];
    };

    Patches.prototype.patchXYtoPixelXY = function(x, y) {
      return [(x - this.minXcor) * this.size, (this.maxYcor - y) * this.size];
    };

    Patches.prototype.importColors = function(imageSrc, f, map) {
      return u.importImage(imageSrc, (function(_this) {
        return function(img) {
          _this.installColors(img, map);
          if (f != null) {
            return f();
          }
        };
      })(this));
    };

    Patches.prototype.installColors = function(img, map) {
      var data, i, patch, _i, _len;
      u.setIdentity(this.pixelsContext);
      this.pixelsContext.drawImage(img, 0, 0, this.numX, this.numY);
      data = this.pixelsContext.getImageData(0, 0, this.numX, this.numY).data;
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        patch = this[_i];
        i = this.pixelByteIndex(patch);
        patch.color = map != null ? map[i] : [data[i++], data[i++], data[i]];
      }
      return this.pixelsContext.restore();
    };

    Patches.prototype.drawScaledPixels = function(context) {
      if (this.size !== 1) {
        u.setIdentity(context);
      }
      if (this.pixelsData32 != null) {
        this.drawScaledPixels32(context);
      } else {
        this.drawScaledPixels8(context);
      }
      if (this.size !== 1) {
        return context.restore();
      }
    };

    Patches.prototype.drawScaledPixels8 = function(context) {
      var a, c, data, i, j, patch, _i, _j, _len;
      data = this.pixelsData;
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        patch = this[_i];
        i = this.pixelByteIndex(patch);
        c = patch.color;
        if (c.length === 4) {
          a = c[3];
        } else {
          a = 255;
        }
        for (j = _j = 0; _j <= 2; j = ++_j) {
          data[i + j] = c[j];
        }
        data[i + 3] = a;
      }
      this.pixelsContext.putImageData(this.pixelsImageData, 0, 0);
      if (this.size === 1) {
        return;
      }
      return context.drawImage(this.pixelsContext.canvas, 0, 0, context.canvas.width, context.canvas.height);
    };

    Patches.prototype.drawScaledPixels32 = function(context) {
      var a, c, data, i, p, _i, _len;
      data = this.pixelsData32;
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        p = this[_i];
        i = this.pixelWordIndex(p);
        c = patch.color;
        a = c.length === 4 ? c[3] : 255;
        if (this.pixelsAreLittleEndian) {
          data[i] = (a << 24) | (c[2] << 16) | (c[1] << 8) | c[0];
        } else {
          data[i] = (c[0] << 24) | (c[1] << 16) | (c[2] << 8) | a;
        }
      }
      this.pixelsContext.putImageData(this.pixelsImageData, 0, 0);
      if (this.size === 1) {
        return;
      }
      return context.drawImage(this.pixelsContext.canvas, 0, 0, context.canvas.width, context.canvas.height);
    };

    Patches.prototype.floodFillOnce = function(aset, fCandidate, fJoin, fCallback, fNeighbors, asetLast) {
      if (fNeighbors == null) {
        fNeighbors = (function(patch) {
          return patch.n;
        });
      }
      if (asetLast == null) {
        asetLast = [];
      }
      return Patches.__super__.floodFillOnce.call(this, aset, fCandidate, fJoin, fCallback, fNeighbors, asetLast);
    };

    Patches.prototype.diffuse = function(v, rate, c) {
      var dv, dv8, neighbor, nn, patch, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref;
      if (this[0]._diffuseNext == null) {
        for (_i = 0, _len = this.length; _i < _len; _i++) {
          patch = this[_i];
          patch._diffuseNext = 0;
        }
      }
      for (_j = 0, _len1 = this.length; _j < _len1; _j++) {
        patch = this[_j];
        dv = patch[v] * rate;
        dv8 = dv / 8;
        nn = patch.neighbors().length;
        patch._diffuseNext += patch[v] - dv + (8 - nn) * dv8;
        _ref = patch.neighbors();
        for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
          neighbor = _ref[_k];
          neighbor._diffuseNext += dv8;
        }
      }
      for (_l = 0, _len3 = this.length; _l < _len3; _l++) {
        patch = this[_l];
        patch[v] = patch._diffuseNext;
        patch._diffuseNext = 0;
        if (c) {
          patch.fractionOfColor(c, patch[v]);
        }
      }
      return null;
    };

    return Patches;

  })(ABM.Set);

  ABM.shapes = ABM.util.s = (function() {
    var ccirc, cimg, circ, csq, fillSlot, poly, spriteSheets;
    poly = function(c, a) {
      var i, p, _i, _len;
      for (i = _i = 0, _len = a.length; _i < _len; i = ++_i) {
        p = a[i];
        if (i === 0) {
          c.moveTo(p[0], p[1]);
        } else {
          c.lineTo(p[0], p[1]);
        }
      }
      return null;
    };
    circ = function(c, x, y, s) {
      return c.arc(x, y, s / 2, 0, 2 * Math.PI);
    };
    ccirc = function(c, x, y, s) {
      return c.arc(x, y, s / 2, 0, 2 * Math.PI, true);
    };
    cimg = function(c, x, y, s, img) {
      c.scale(1, -1);
      c.drawImage(img, x - s / 2, y - s / 2, s, s);
      return c.scale(1, -1);
    };
    csq = function(c, x, y, s) {
      return c.fillRect(x - s / 2, y - s / 2, s, s);
    };
    fillSlot = function(slot, img) {
      slot.context.save();
      slot.context.scale(1, -1);
      slot.context.drawImage(img, slot.x, -(slot.y + slot.bits), slot.bits, slot.bits);
      return slot.context.restore();
    };
    spriteSheets = [];
    return {
      "default": {
        rotate: true,
        draw: function(c) {
          return poly(c, [[.5, 0], [-.5, -.5], [-.25, 0], [-.5, .5]]);
        }
      },
      triangle: {
        rotate: true,
        draw: function(c) {
          return poly(c, [[.5, 0], [-.5, -.4], [-.5, .4]]);
        }
      },
      arrow: {
        rotate: true,
        draw: function(c) {
          return poly(c, [[.5, 0], [0, .5], [0, .2], [-.5, .2], [-.5, -.2], [0, -.2], [0, -.5]]);
        }
      },
      bug: {
        rotate: true,
        draw: function(c) {
          c.strokeStyle = c.fillStyle;
          c.lineWidth = .05;
          poly(c, [[.4, .225], [.2, 0], [.4, -.225]]);
          c.stroke();
          c.beginPath();
          circ(c, .12, 0, .26);
          circ(c, -.05, 0, .26);
          return circ(c, -.27, 0, .4);
        }
      },
      pyramid: {
        rotate: false,
        draw: function(c) {
          return poly(c, [[0, .5], [-.433, -.25], [.433, -.25]]);
        }
      },
      circle: {
        shortcut: function(c, x, y, s) {
          c.beginPath();
          circ(c, x, y, s);
          c.closePath();
          return c.fill();
        },
        rotate: false,
        draw: function(c) {
          return circ(c, 0, 0, 1);
        }
      },
      square: {
        shortcut: function(c, x, y, s) {
          return csq(c, x, y, s);
        },
        rotate: false,
        draw: function(c) {
          return csq(c, 0, 0, 1);
        }
      },
      pentagon: {
        rotate: false,
        draw: function(c) {
          return poly(c, [[0, .45], [-.45, .1], [-.3, -.45], [.3, -.45], [.45, .1]]);
        }
      },
      ring: {
        rotate: false,
        draw: function(c) {
          circ(c, 0, 0, 1);
          c.closePath();
          return ccirc(c, 0, 0, .6);
        }
      },
      person: {
        rotate: false,
        draw: function(c) {
          poly(c, [[.15, .2], [.3, 0], [.125, -.1], [.125, .05], [.1, -.15], [.25, -.5], [.05, -.5], [0, -.25], [-.05, -.5], [-.25, -.5], [-.1, -.15], [-.125, .05], [-.125, -.1], [-.3, 0], [-.15, .2]]);
          c.closePath();
          return circ(c, 0, .35, .30);
        }
      },
      names: function() {
        var name, val, _results;
        _results = [];
        for (name in this) {
          if (!__hasProp.call(this, name)) continue;
          val = this[name];
          if ((val.rotate != null) && (val.draw != null)) {
            _results.push(name);
          }
        }
        return _results;
      },
      add: function(name, rotate, draw, shortcut) {
        var s;
        if (u.isFunction(draw)) {
          s = {
            rotate: rotate,
            draw: draw
          };
        } else {
          s = {
            rotate: rotate,
            img: draw,
            draw: function(c) {
              return cimg(c, .5, .5, 1, this.img);
            }
          };
        }
        this[name] = s;
        if (shortcut != null) {
          return s.shortcut = shortcut;
        } else if ((s.img != null) && !s.rotate) {
          return s.shortcut = function(c, x, y, s) {
            return cimg(c, x, y, s, this.img);
          };
        }
      },
      poly: poly,
      circ: circ,
      ccirc: ccirc,
      cimg: cimg,
      csq: csq,
      spriteSheets: spriteSheets,
      draw: function(context, shape, x, y, size, rad, color) {
        if (shape.shortcut != null) {
          if (shape.img == null) {
            context.fillStyle = u.colorString(color);
          }
          shape.shortcut(context, x, y, size);
        } else {
          context.save();
          context.translate(x, y);
          if (size !== 1) {
            context.scale(size, size);
          }
          if (rad !== 0) {
            context.rotate(rad);
          }
          if (shape.img != null) {
            shape.draw(context);
          } else {
            context.fillStyle = u.colorString(color);
            context.beginPath();
            shape.draw(context);
            context.closePath();
            context.fill();
          }
          context.restore();
        }
        return shape;
      },
      drawSprite: function(context, s, x, y, size, rad) {
        if (rad === 0) {
          context.drawImage(s.context.canvas, s.x, s.y, s.bits, s.bits, x - size / 2, y - size / 2, size, size);
        } else {
          context.save();
          context.translate(x, y);
          context.rotate(rad);
          context.drawImage(s.context.canvas, s.x, s.y, s.bits, s.bits, -size / 2, -size / 2, size, size);
          context.restore();
        }
        return s;
      },
      shapeToSprite: function(name, color, size) {
        var bits, context, foundSlot, img, index, shape, slot, x, y;
        bits = Math.ceil(ABM.patches.toBits(size));
        shape = this[name];
        index = shape.img != null ? name : "" + name + "-" + (u.colorString(color));
        context = spriteSheets[bits];
        if (context == null) {
          spriteSheets[bits] = context = u.createContext(bits * 10, bits);
          context.nextX = 0;
          context.nextY = 0;
          context.index = {};
        }
        if ((foundSlot = context.index[index]) != null) {
          return foundSlot;
        }
        if (bits * context.nextX === context.canvas.width) {
          u.resizeContext(context, context.canvas.width, context.canvas.height + bits);
          context.nextX = 0;
          context.nextY++;
        }
        x = bits * context.nextX;
        y = bits * context.nextY;
        slot = {
          context: context,
          x: x,
          y: y,
          size: size,
          bits: bits,
          name: name,
          color: color,
          index: index
        };
        context.index[index] = slot;
        if ((img = shape.img) != null) {
          if (img.height !== 0) {
            fillSlot(slot, img);
          } else {
            img.onload = function() {
              return fillSlot(slot, img);
            };
          }
        } else {
          context.save();
          context.scale(bits, bits);
          context.translate(context.nextX + .5, context.nextY + .5);
          context.fillStyle = u.colorString(color);
          context.beginPath();
          shape.draw(context);
          context.closePath();
          context.fill();
          context.restore();
        }
        context.nextX++;
        return slot;
      }
    };
  })();

}).call(this);

//# sourceMappingURL=agentscript.map
